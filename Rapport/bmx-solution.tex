\section{BioMérieux Solution}

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.5]{img/bmx.png}
    \caption{Logo de bioMérieux}
\end{figure}

BioMérieux est une entreprise spécialisée dans le diagnostic in vitro et dans la microbiologie.
Cette entreprise concoit et fabrique des instruments permettant de diagnostiquer des maladies et de faire des analyses microbiologiques.
BioMérieux dispose d'un showroom permettant de montrer leur produits à leurs futurs clients.

\subsection{Situation initial}

Dans ce Showroom, un ensemble de dispositifs interactifs sont mis en place pour presenter les produits et l'entreprise.
Parmis ces équipements, on retrouve l'espace solution.
Cet espace présente un exemplaire physique des principales machines concus par BioMérieux.
Un projecteur permet alors d'afficher une image sur une vitre opacifiante, cette image projetée est l'écran d'un Mac Mini disposé dans la salle technique du Showroom;
On utilise un lidar\footnote{Le lidar est un laser rotatif permettant, par balayage, de detecter la position d'un element dans l'espace.} pour reperer l'emplacement du doigt sur la vitre et ainsi controler l'ordinateur.

L'application présente avant ma mission etait développée en C++ avec OpenFrameworks\footnote{OpenFrameworks est un framework se basant sur de nombreuses librairies permettant la creation simplifiée d'applications graphiquement poussées. Il est très utilisé dans le domaine de la scenographie et du creative coding.}.
Cette application présente un arbre de composents graphiques chacun affichant un élément de l'interface.
Ce système, bien que fonctionnel, est assez peux flexible au regard des nouvelles fonctionnalités demandés par BioMérieux.

En effet, bioMérieux à recemment changé son logo et sa charte graphique pour un aspect plus épuré et flat-design\footnote{Le flat-design est un courant de design moderne qui possède une approche minimaliste de l'interface en se basant sur des aplats de couleurs unis et des effets d'ombres.}.
Pour reflèter ce changement dans leur showroom, l'entreprise a demandé un redesign de l'application.
De plus, pour pouvoir gèrer par eux même les produits presents dans l'application, bioMérieux a demandé la mise en place d'un backoffice qui permettra d'éditer le contenu de l'application sans faire appel à LTBL .

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.195]{img/resized-bmx-1-new.jpg}
    \includegraphics[scale=0.195]{img/resized-bmx-2-new.jpg}
    \includegraphics[scale=0.195]{img/resized-bmx-3-new.jpg}
    \includegraphics[scale=0.195]{img/resized-bmx-4-new.jpg}
    \caption{Design renouvelé de l'application Biomérieux}
\end{figure}

Enfin, dans une optique de recherche et développement d'une soltion universelle de backoffice chez LTBL il fallait aussi réfléchir à un système flexible de stockage de données.

Pour résumer, les fonctionnalités demandés sont :

\begin{itemize}
    \item La mise à jour de la charte graphique de bioMérieux
    \item La mise en place d'un backoffice pour gèrer les produits
    \item Faire en sorte que le backoffice puisse être réutilisé dans d'autres projets LTBL
\end{itemize}


\subsection{Conception de la solution}

Le code précédent étant totalement fait main, il est peu flexible et sensible aux bugs de développement.
De plus les données sont directement integrés dans le code et il serait chronophage et peu rentable de modifier cette application pour qu'elle s'adapte aux nouveaux besoins.
J'ai donc décidé de reprendre l'application depuis le début et de choisir une solution technique qui me semble plus adaptée à une interface.

Pour ce projet, j'ai utilisé \emph{Electron} qui permet de créer des interfaces facilement à l'aide des technologies Web.
Je m'y penche plus en détails dans la partie suivante.

Pour le stockage des données, j'ai opté pour une base de données \emph{SQLite} permettant un stockage dans un fichier sans serveur superflu.
En effet, SQLite est une librairie C mettant à disposition un langage SQL et un stockage de données dans un fichier.
Cette technique est très intéressante dans notre cas, car les données ne seront qu'utilisées par l'application.
De plus, l'application ne nécessite pas de grandes performances et donc pas d'optimisation particulière que peuvent présenter les serveurs SGBDR\footnote{Système de Gestion de Bases de Données relationnelles} comme MariaDB ou PostgreSQL\@.

Enfin, pour gérer ces données j'utilise \emph{Sequelize}, un ORM JavaScript permettant de communiquer avec la base de données.
Cette librairie permet de représenter les données sous forme d'objets JavaScript pour éviter d'écrire les requêtes à la main et ainsi avoir une meilleure intégration des données dans l'environnement JavaScript.

\subsubsection{Electron}

Pour développer l'application j'ai décidé d'utiliser Electron.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.2]{img/electron.png}
    \caption{Logo de Electron}
\end{figure}

Electron est un framework permettant de concevoir des application natives en utilisant les technologies web.
Il embarque le moteur de rendu et le moteur Javascript de Chromium mais ajoute les fonctionalités de NodeJS permettant d'interagir avec le système hote.
Chromium est l'un des navigateurs les plus avancés dans l'integration des nouvelles normes et cela permet de profiter de nouvelles fonctionnalités très intéressantes comme les Webcomponents et WebGL .
Enfin, on peut toujours accèder au système de fichiers de l'utilisateur et faire de la dépendances de modules NodeJS avec les fonctionnalités que propose Electron en plus des fonctionnalités de base que l'on retrouve sur un site web classique.

L'utilisation de ce framework est intéressant dans le cas de cette application car elle permet de concevoir des interfaces simplement.
Les langages web sont spécifiquement dédiés à la creation d'interfaces comme le demande notre projet.
Ainsi, on peut estimer que recoder l'application avec un nouveau design et le nouvelles fonctionnalités prendrais moins de temps que d'adapter l'ancienne application.

\subsubsection{WebComponents}
\label{webcomponents}

Le système de Webcomponents est un ensemble de nouvelles normes mises en place il y a peu de temps par le W3C et implémentés dans Chromium permettant de créer de nouveaux tags HTML avec des fonctionnalités spécifiques et isolés du reste de l'archithecture de la page.

\bigskip

Un Webcomponent est basé sur 4 normes :

\paragraph{Custom Elements} Une fonctionnalité permettant de créer un tag HTML personnalisé et reconnu par le navigateur comme faisant référence au code associé sous forme de classe.

\paragraph{HTML Template} Le tag \texttt{<template>} permet de créer un élément qui ne sera pas visible par l'utilisateur mais qui servira de squelette pour la creation de futurs éléments.
Dans les Webcomponents, on les utilisent pour créer le squelette de base de notre component.

\paragraph{Shadow DOM} Un concept permettant d'isoler une partie de l'arborescense d'une page Web.
Cela implique l'isolation du style et des éléments.
Cette technologie sert à créer le contenu caché de notre futur élément qui apparaitra comme une blackbox.

\paragraph{HTML Import} Permet d'importer un fichier HTML externe.
Cela permet notemment d'inclure tout le code HTML, CSS et JS d'un component dans un même fichier HTML.
Il suffira ensuite d'importer cet unique fichier pour pouvoir utiliser le component.

\bigskip

Le développement en Webcomponent présente de nombreux avantages.
L'isolation du style CSS dans le Shadow DOM permet de ne pas provoquer de conflit CSS lors d'une séléction un peu trop générale sur le fichier de styles de base.
L'isolation du javascript permet de se concentrer uniquement sur le composant sans interferer avec le reste de l'application.
Enfin, l'approche unitaire des Webcomponents permet une réusablitié importante.

Mais l'approche par component pose aussi des difficultés.
En effet, il faut penser le composent en tant qu'élément générique.
Si on fait un composent trop spécifique ou dépendant de ses voisins, il sera difficile de réutiliser le composant dans un autre contexte de celui pour lequel il etait prévu au début.
Cela implique de réfléchir à la structure de l'application en amont.
Et il ne faut plus penser l'application dans son ensemble mais comme une ensemble de blocs réutilisables ajoutés les uns aux autres.

Faire un bloc réutilisable passe par l'utilisation des attributs HTML comme vecteurs de transmission d'informations.
Mais aussi l'utilisation d'évennements Javascript comme vecteur de signal pour avertir les parents.

\bigskip

Dans ce projet, j'ai été amené à découvrir cette nouvelle norme du W3C par le biais des employés de l'entreprise qui utilisaient déjà cette technologie.
J'ai découvert les webcomponents et ai expérimenté avec ceux ci durant ce projet.
J'ai eu l'occasion, par le suite, d'affiner mes connaissances sur le sujet dans le cadre des 5 autres projets qui les utilisent.

\subsection{Structure}

Pour cette structure, j'ai puisé dans mes connaissances acquises durant ma formation pour concevoir un système en 3 blocs.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.6]{img/Proposition-utopia.pdf}
    \caption{Structure générale de l'application Biomérieux}
\end{figure}

\subsubsection{Modèle}

Le modèle est la partie de l'application qui définis l'organisation et le stockage des données requis par les éléments de l'interface.

Pour définir et stocker les donnée j'utilise la librairie d'ORM\footnote{Un ORM est une librairie apportant une couche d'abstraction aux reqètes SQL par l'utilisation des fonctionnalités Orientée Objet du langage dans laquelle elle est implémentée (Ex : Doctrine en PHP, Sequelize en JavaScript, Django ORM en Python, etc.)} \emph{Sequelize}.
Elle a pour avantage d'être compatible avec la majeure partie des bases de données relationnelles les plus connues comme MySql, PostgreSQl, SQLite, etc.
Dans cet ORM, on doit définir un modèle, ce modèle sera utilisé pour créer les tables de la base de données.
J'ai décidé de définir ce modèle dans un unique fichier \texttt{model.js} permettant de centraliser leurs déclarations pour facilement les adapter en cas de changement d'avis du client.

L'objectif de cette structure est d'être le plus flexible possible pour pouvoir reprendre le même code dans un tout autre système.

\bigskip

Dans le cas de cette application pour BioMérieux, j'ai décidé de découper les données en 5 entités.
Ces entités représentent une table dans la base de données et permettent de faire le lien entre cette table et le code de l'applicaiton.
Pour construire ce modèle de données, je me suis basé sur les designs de l'application faits par le graphiste et des informations données par mon maitre de stage.
L'une des difficultés ici fut de ne pas avoir de cahier des charges défini, ce qui m'obligé à reprendre mon modèle plusieurs fois.
Mais la grande flexibilité du système m'as permis de continuer à développer sans me soucier de ces changements.

\bigskip

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.6]{img/uml-bmx-solution.png}
    \caption{Le diagramme UML du modèle de données de l'application BioMérieux Solution}
\end{figure}

\clearpage

J'ai donc mis en place les entités suivantes

\paragraph{Produit} L'entités représentant un produit de Biomérieux.
Il contiens un \emph{nom}, une \emph{description} en texte riche\footnote{Un texte riche est un ou plusieurs paragraphes formatés suivant une certaine syntaxe; On peut donc y ajouter des passages en gras, italique, insèrer des images et des listes}, une \emph{image} uplodée, d'un \emph{identifiant de lampe} permettant d'envoyer des commandes OSC\footnote{Le protocol OSC (Open Sound Control) permet d'envoyer des commandes dans des paquets UDP au travers du réseau; Il est três utilisé dans la scenographie pour faire communiquer les différents éléments de l'espace comme des lampes, des moteurs, etc.} et d'une image de présentation.

\paragraph{Technology} Une technologie de produit, permettant de classifier les produits.
Un même produit est associé à une seul technologie.
Une technologie ne contien qu'un \emph{nom}.

\paragraph{Thematic} Une thématique permet de regrouper les produits en diverses catégories.
Il est ainsi possible d'ajouter un même produit à plusieurs thématiques.
Une thématique permet de classifier les produits dans divers domaine d'expertise.
Une thémétique possède un \emph{nom} et une \emph{tagline} représentant le slogan de cette thématique.
Chaque thématique peut contenir plusieurs produit et un même produit peut se retrouver dans plusieurs catégories.

\paragraph{SuperThematic} Une thématique contenant pusieurs sous-thématiques.
J'ai choisi de créer une super thématique au lieu de faire une arboréscense de thématique car le client ne dit pas vouloir une arborécense plus grande que 2 niveaux.
Mais aussi qu'il ne faut pas pouvoir ajouter des produits dans les super thématiques.
Une super thématique ne contien qu'un \emph{nom} tout comme les thématiques mais peut contenir plusieurs thématiques.

\paragraph{GalleryImage} Chaque produit dispose de plusieurs images disposé dans une gallerie consultable par l'utilisateur.
Cette entitée permet alors de créer une image de cette gallerie.
Une produit peut contenir plusieurs images et chaque image dispose d'un \emph{chemin} vers l'image uploadée et d'une \emph{position} dans la gallerie représentée par un nombre.
Les images sont alors triées dans l'ordre de ce champ.

\subsubsection{BackOffice}

Un BackOffice est une interface simplifiée permettant au client final d'éditer le contenu de l'application sans l'intervention des créateurs.
Cela peut passer par un logiciel compagnon ou une interface Web.
Dans mon cas, j'ai choisi la deuxième option pour éviter de demander le développement et et l'installation d'une deuxième, application.

Le BackOffice est un serveur web exécuté au sein de l'application Electron.
Ce serveur web se base sur le modèle pour créer les formulaires de saisie des données.
Le back-office ne présente aucun code spécifique au modèle de BioMérieux, mais met en place une arborescence de formulaires générés en fonction du modèle défini par le développeur.
Cette technique permet de réutiliser ce back-office dans un tout autre contexte mais permet aussi de changer le modèle sans difficulté.

Pour ce backoffice j'ai utilisé \emph{Express} Une librairie permettant de créer des application Web très simplement et le moteur de template \emph{twig} que j'ai déjà utilisé dans le projet Web de l'exia.

\bigskip

Avec le recul de mon stage, je me rend compte que le développement d'une application compagnon aurait été plus interessante pour éviter qu'un pirate ayant accès au réseau de l'application puisse librement en modifier le contenu.
De plus, cela aurai permis d'améliorer les performances en évitant de démarre un serveur web à chaque utilisation de l'interface client.

Mais, l'approche que j'ai utilisé permet une plus grande simplicité d'opération par la mise à jour en direct de la vue client et l'absence de fichier à transfèrer.

\subsubsection{Affichage client}

 L'affichage client représente tout ce qui va être affiché par l'application Electron sur le terminal.
Cet affichage est le seul qui sera vu par les visiteurs du showroom.
Dans l'architecture utilisée, c'est la seul partie spécifique.
Dans cette partie, on utilise les WebComponents (\emph{cf} partie \ref{webcomponents}) pour concevoir l'application.

Parmi ces WebComponents, j'en ai créé des génériques permettant d'effectuer des tâches de base.


\paragraph{DataElement} Le plus important de ces WebComponents car il permet, en tout point de l'application, de récupèrer des données depuis la base de données et d'être averti quand ces données changent.
Cela permet de récupèrer les données mais aussi d'actualiser la vue en direct dès la modification de ceux-ci.
Cela est rendu possible par deux processus :
\begin{description}
    \item[Hooks Sequelize] Les entités sequelize diposent de Hooks permettants d'appeler un fonction lors d'action spécifiques comme la creation, la supression ou la mise à jour de l'entitée. J'utilise ces Hooks pour alerter le \texttt{<data-element>} de la modification des données.
    \item[IPC Electron] Electron, tout comme chromium, est un logiciel multi-processus. Le processus initial se charge de démarrer un processus enfant pour afficher les données. Ce processus initial est aussi en charge de la mise en route du back office. Pour que les modifications soient éfféctués dans tout les processus, j'envoie un signal IPC contenant l'entitée modifiée pour qu'elle soit mise à jour dans tout les processus.
\end{description}

\paragraph{PageRouter} L'élément \texttt{<page-router>} permet de simuler le fonctionnement d'un système multipage.
Chaque élément placé dans ce Webcomponent dispose de d'un attribut \texttt{route} définissant l'URL de la page.
Une route peut contenir n'importe quel carractère mais aussi des attributes en faisant précèder le nom du paramètre par des \texttt{:}.
On peut alors choisir la page à afficher en entrant l'URL de celle-ci dans l'attribut \texttt{page} du webcomponent \texttt{<page-router>}.

\paragraph{AnimationBlock} Un webcomponent d'animation se basant sur les modules d'animation de AngularJs ou de VueJs.
Il permet d'animer les éléments de l'interface a la fin de la production de l'application et de manière flexible.
Il se base sur les transtions CSS pour de grandes performances et ne s'active que lors du focus sur l'application.
J'en parle plus en details dans la partie \ref{animationblock}.

\subsection{Installation}
\label{bmxinstallation}

La première installation de l'application s'est déroulée le 7 février dans les locaux de BioMérieux.
J'ai pu y découvrir le nouveau bâtiment de l'entreprise et son showroom très impressionnant.

Le dispositif est disposé sur une vitre opacifiante et le dispositif de pointage (autrefois un lidar) est remplacé par une caméra infrarouge et un stylo spécifique.
Ce système permet une précision de pointage plus importante et un système plus discret.

Malheuresement, en raison d'un problème touchant l'ensemble du showroom, je n'ai pas eu l'occasion de tester l'application condition réél.
Mai j'ai tout de même pus soumettre mon application a l'utilisateur final qui semble interessé par les nouvelles fonctionnalités.

Une nouvelle installation est planifiée pour le 12 Avril pour installer mon application dans le showroom et démarrer les premier tests en conditions réél.

\subsection{Conclusion}
\label{bmxconclusion}

Ce projet fut le premier au sein de l'entreprise LTBL.
J'ai eu l'occasion de ma familiariser avec les services, l'équipe de développement et de design et de découvrir les téchnologies utilisés en interne.

Ce projet fut mon premier projet utilisant les WebComponents et il m'a donné envie de creuser dans cette direction tant le sujet est vaster et interessant.
En revanche, je me rend compte en fin de stage, que j'ai fait des érreurs de structure dans mon découpage.
Ces érreurs ne peuvent malheuresement pas être corrigées dans le peu de temps qu'il me rêste pour finir mon stage mais me permettent de constater mon avancée dans cette nouvelle technologie.