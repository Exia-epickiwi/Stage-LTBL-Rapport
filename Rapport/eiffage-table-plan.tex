\section{Eiffage table plan}
\label{eiffageTablePlan}

%TODO Afficher des plans
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.5]{img/table-plan-capture.png}
    \caption{Capture d'écran de l'application Table Plan}
\end{figure}

Dans le trio d'applications de la nouvelle salle cokpit d'Eiffage, l'application d'édition de plan m'a été accordée en partie.
L'objectif de cette application est d'afficher et de permettre la manipulation de plans (au format PDF) issus de  l'espace réseau d'Eiffage.
Cette application est affichée sur un ecran intègré dans une table faite sur mesures permettant l'interaction de plusieurs personnes au même moment.

Le cahier des charge de cette application est le suivant :
\begin{itemize}
    \item Charger et afficher des plans depuis le réseau d'Eiffage
    \item Permettre aux utilisateurs de manipuler les plans affichés
    \item Permettre aux utilisateurs d'annoter les plans affichés et d'enregistrer ces annotations pour les transmettre à l'archithecte
    \item Utiliser un design compatible avec l'affichage sur une table tactile ou plusieurs personnes sont assises autour d'un écran affichant l'application.
\end{itemize}

\subsection{Application existante}
\label{eiffageTablePlanApplicationExistante}

Cette application était la plus avencée des trois lors du début du projet.
L'équipe précédente avait beaucoup travaillé sur l'affichage des PDF.

En effet, les PDF de Eiffage sont très lourds et demandent un affichage particulier.
L'équipe ayant travaillé sur ce projet a donc beaucoup réfléchis à la technologie à utiliser pour afficher les PDF sans ralentissements.
Ils ont donc opté pour une apploche orientée Web avec un chargement, non pas du PDF en lui même, mais d'une image de ce PDF rendue a l'aide de ImageMagick.
Ils ont alors utilisé PixiJs, une librairie 2D pour WebGL, pour afficher l'image du PDF et permettre l'annotation.

Le plus gros de l'application, l'edition de plan, etait déjà codée et j'ai donc eu l'objectif de créer l'interface pour qu'elle reflète les creations du designer.
Mais aussi que l'application soit utilisable en collaboration et donc autour d'une table.

En revanche, l'ancienne application n'utilisait pas les WebComponents et j'ai du m'adapter pour reformer le code présent.
De plus, le développeur me précédent, n'avait pas dutout les même habitudes de développement et la même structure que moi et j'ai donc eu une longue phase d'analyse pour comprendre le rôle de chaque élément.

\subsection{Technologie}
\label{eiffageTablePlanTechnologie}

Les technologies utilisés dans le cadre de ce projet sont les même que les autres applications de ce type crées par LTBL.
On y retrouve Electron pour l'affichage de l'application et les Webcomponents pour la structcure interne.

\subsection{Structure}
\label{eiffageTablePlanStructure}

L'application se divise alors en de multiples WebComponents chacun ayant un rôle spécifique.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.5]{img/table-plan-structure.pdf}
    \caption{Structure de l'application Table Plan}
\end{figure}

On retrouve alors les composants suivants

\paragraph{Blueprint player} Un component en charge d'afficher et d'annoter un plan dans notre cas.
Ce component etait déjà, en grande partie, conçu quand j'ai débuté le développement de l'interface.
Aisin, je n'ai eu qu'à l'integrer dans l'application finale.

\paragraph{Tab menu} Le menu composé de différents onglets.
Chaque onglet représente un plan ouvert qui peut être affiché.
Ce component est présent en 2 exemplaires dont un retourné sur le haut de l'application déstiné aux utilisateur présent de l'autre coté de la table.
J'ai synchronisé l'etat de ces deux components avec un système de Store (\emph{cf} partie\ref{eiffageTablePlanStores})

\paragraph{Toolbar} Un composant affichant divers boutons permettant de choisir l'outil à utiliser dans sur le plan affiché.
Ce component est présent en 4 exemplaires dans l'application et doit donc être synchronisé avec ses voisins.
J'ai aussi utilisé le système de store pour synchroniser les états des barres d'outils et des éditeurs de plans (\texttt{Blueprint Player}).

\bigskip

Dans cette application, j'ai aussi utilisé le component \texttt{Media reader} du projet précédent pour offrire une interface unifiée sur toutes les application développées pour Eiffage.
Je l'ai ajouté par le biais des submodules Git et de quelques petits ajustements dans le code de base de l'explorateur.

\subsection{Style}
\label{eiffageTablePlanStyle}

L'un des points majeurs de cette mission fut le style de l'application.
En effet, on est loin d'une application standard éxécutée sur un bureau.
On remarque que l'utilisation faite de cette application nécéssite une mise en place particulière des éléments de l'interface.

On remarque notemment que les barres d'outils sont présentes au 4 coins de l'interfaces toutes dirigés vers l'exterieur de l'application pour permettre an'importe quel collaborateur autour de la table d'interagir avec les plans.
Cela a demandé la mise en place d'une synchronisation des barres d'outils au niveau de l'application et l'utilisation de propriétés CSS de transformations a des fins bien plsu ergonomiques qu'esthetiques.

\bigskip

On remarque aussi que la barre des onglets ouverts est aussi inversé sur la partie superieur de l'application.
Cela a demandé une modification au niveau du code lui même car je ne pouvais pas me contenter d'éffectuer un mirroir sur l'élément (ce que j'ai fait pour les barres d'outils).
La raison de cette spécificité est la présence de texte.
Mettre un effet de mirroir sur un texte le rend completement illisible (contrairement à un icone) et j'ai éfféctué une rotation au lieu de faire un mirroir.
Mais cela posé d'autres problèmes puisque la droite et la gauche etait inverée sur chacun des éléments.
J'ai donc modifié le code source du composant de la barre d'onglets pour qu'elle inverse toutes les commandes dans certains cas.

\subsection{Stores}
\label{eiffageTablePlanStores}

Par son style particulier et la dimention collaborative de la table, de nombreux éléments de l'interface doivent être synchronisés.
Par exemple, il faut synchroniser l'etat des barres tout'ils pour qu'elles affichent en tout temps le bon outil en cours d'utilisation même si cet outil est changé depuis un élément exterieur comme une autre barre d'outils.

J'ai, dans un premier temps, imaginé un système inclus dans les components permettant de les lier directement pour q'ils s'informent entre eux lors d'un changement d'état d'un coté.

\begin{figure}[h]
    \centering
    \includegraphics[scale=1]{img/premiere-synchro.pdf}
    \caption{Premier système de sychronisation utilisé dans le cas des barres d'outils de l'application}
\end{figure}

Cela fonctionnait, mais je me suit vite heurté à la rigidité de ce système et à la complexité d'étendre les fonctionnalités de ce système à l'application entière.
J'ai donc puisé dans mes connaissance et me suis inspiré des solutions trouvés dans des librairies comme \emph{Vuex} pour concevoir les Stores.

Un store est une classe Singleton\footnote{Une classe qui ne peut être instanciée qu'une seul fois et accessible par tout le programme}  qui va stocker un état particulier.
Cette classe est observable et peut donc informer les éléments de l'interface qui lui sont abonnés des changements apportés à l'etat du store.
Ce système permet de centraliser la gestion des informations à l'echelle de l'application sans pour autant rendre les components dépendants les uns des autres.
De plus ce système permet un grande flexibilité car on peut modifier l'etat à n'importe quel endroit de l'interface.
Ces changements seront alors répercutés sur l'ensemble de l'application automatiquement et dynamiquement.

\begin{figure}[h]
    \centering
    \includegraphics[scale=1.5]{img/store.pdf}
    \caption{Le fonctionnement du store dans le cadre de la gestion des barres d'outils}
\end{figure}

J'ai alors réutilisé ce système dans la gestion des plans ouverts et en cours de conversion (\emph{cf} partie \ref{eiffageTablePlanConversion}) sur Tableplan.
Mais aussi dans les autres applications que j'ai été amené à développer à la suite de celle-ci.

\clearpage

\subsection{Conversion}
\label{eiffageTablePlanConversion}

Les plans d'Eiffage etant très lourds, ils sont impossible à ouvrir tel quel dans l'application.
Il faut donc utiliser un logiciel de conversion pour rendre les PDF sous forme d'image.

Les PDF de plans d'eiffage etant des plans vectoriels\footnote{Une image vectorielle est une image dont on ne spécifie pas la couleur de chaque pixel mais on spécifie une suite d'instruction permettant de calculer l'image finale. Les fichiers PDF, AI et SVG sont des exemples de fichiers vectoriels} ils nécéssitent un calcul préalable pour les afficher.
Pour résoudre le problème de loudeur des fichiers, j'ai mis en place un système de conversion automatique des plans.

\bigskip

Des qu'un fichier PDF est ouvert, on vérifie dans un dossier de cache s'il n'est pas déjà converti.
Si il l'es, on ouvre simplement la conversion précédente.
S'il ne l'est pas, on lance un conversion.
On informa alors l'utilisateur de la conversion en cours et on attend la fin de cette conversion avant d'ouvrir le fichier converti.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.3]{img/image-magick.png}
    \hspace{5cm}
    \includegraphics[scale=0.13]{img/ghostscript.png}
    \caption{Les logis de ImageMagick (à gauche) et GhostScript (à droite)}
\end{figure}

La conversion est effectuée avec ImageMagick, un logiciel de manipulation d'images très performant, et de GhostScript, un logiciel permettant de rendre des fichiers PDF avec ImageMagick.

Pour permettre un rendu optimal dans toutes les circonstances, nous avons choisi de rendre les plans en 4K et de les afficher dans une fenètre 4 fois superieur à leur taille pour avoir un trai d'annotation fin bien défini.

\subsection{Conclusion}
\label{eiffageTablePlanConclusion}

Ce projet fut pour moi l'occasion d'éxpérimenter plus en profondeur les stockage des données au sein d'une application basée sur des composants.
Ce fut aussi une bonne experiance de travail en équipe car je n'ai développé que l'interface qui entourait un système d'affichage et d'annotation de plans développé par le rêste de l'equipe.